
## 8.1 序列

序列的特点：可迭代的、有序的、元素可以重复。  
序列包括的结构有：列表（list）、字符串（str）、元组（tuple）、范围（range）和字节序列（bytes）。  
序列可进行的操作有：索引、分片、加和乘。

### 8.1.1 索引操作

正索引：  

|索引：|0|1|2|3|4|
|------|-|-|-|-|-|
|字符串：|H|E|L|L|O|

负索引：

|索引：|0（-5）|-4|-3|-2|-1|
|------|:-:|-|-|-|-|
|字符串：|H|E|L|L|O| 

正负索引的第一个元素均为0。

    >>> a = 'Hello'
    >>> a[0]
    'H'
    >>> a[1]
    'e'
    >>> a[-1]
    'o'
    >>> a[-2]
    'l'
    >>> 
    >>> a[-4]
    'e'
    >>> a[-5]
    'H'
    >>> a[-6]
    Traceback (most recent call last):
    File "<pyshell#8>", line 1, in <module>
    a[-6]
    IndexError: string index out of range
    >>>

### 8.1.2 序列的加和乘

    >>> a * 3
    'HelloHelloHello'
    >>> a += "World"
    >>> a
    'HelloWorld'
    >>>

### 8.1.3 序列分片

序列的分片（slicing）就是从序列中切分出小的子序列。  
分片运算符有两种形式：

1: [start:end]  
Start：是开始索引  
End：是结束索引  
2: [start: end :step]  
Start：是开始索引  
End：是结束索引  
Step：是步长  

步长是在分片时获取元素的间隔。  
步长可以为正数，也可以包括start元素，但不包括end元素。    

     下次元素索引 = 当次元素索引 + 步长

    >>> a = 'Hello'
	>>> a[1:3]
	'el'
	>>> a[4:5]
	'o'
	>>> a[:3]
	'Hel'
	>>> a[0:]
	'Hello'
	>>> a[0:5]
	'Hello'
	>>> a[:]
	'Hello'
	>>> a[1:-1]
	'ell'
	>>> a[1:5]
	'ello'
	>>> a[1:5:2]
	'el'
	>>> a[1:5:3]
	'eo'
	>>> a[0:3]
	'Hel'
	>>> a[0:3:2]
	'Hl'

当步长为负数时，起始索引要比结束索引要大。  

    >>> a = 'Hello'
	>>> a[4:3:-1]
	'o'
	>>>

当开始索引、结束索引均没有，而步长为-1时，会将整个序列倒置。  

	>>> a[::-1]
	'olleH'

## 8.2 元组

元组的特点：一种不可变的序列，一旦创建不可以修改。  

### 8.2.1 创建元组

创建元组可以使用 'tuple([iterable])' 函数或者直接用逗号（，）将元素分隔。  
注意：  
tuple函数中的参数类型为序列类型。  

例如：  
1: 直接输入数字组成元组  
  
    >>> 21,3,3,4,54
    (21, 3, 3, 4, 54)
    
2：通过小括号赋值创建元组  

	>>> a = (21,3,3,4,54)
	>>> a
	(21, 3, 3, 4, 54)
	>>> type(a)
	<class 'tuple'>

3：没用括号，直接赋值创建元组  

	>>> a = 2,3,4,5
	>>> a
	(2, 3, 4, 5)
	>>> type(a)
	<class 'tuple'>

4：只创建一个元素的元组

	>>> a = 2,
	>>> a
	(2,)
	>>> type(a)
	<class 'tuple'>

注意：不加“，”是不行的会被认为整数类型赋值。  

	>>> a = 2
	>>> a
	2
	>>> type(a)
	<class 'int'>

	>>> a = (2)
	>>> a
	2
	>>> type(a)
	<class 'int'>

5：创建空的元组  

	>>> a = ()
	>>> a
	()
	>>> type(a)
	<class 'tuple'>

### 8.2.2 访问元组

#### 8.2.2.1 通过索引访问元组

例如：  

	>>> a = ('Hello',"World",1,3,4)
	>>> a[1]
	'World'
	>>> a[0]
	'Hello'
	>>> a[3]
	3

注意，在使用索引时不要越界。  

	>>> a[5]
	Traceback (most recent call last):
	  File "<pyshell#33>", line 1, in <module>
	    a[5]
	IndexError: tuple index out of range

#### 8.2.2.2 通过“分片”访问元组

例如：

	>>> a = ('Hello',"World",1,3,4)
	>>> a[1:3]
	('World', 1)
	>>> a[2:]
	(1, 3, 4)
	>>> a[:2]
	('Hello', 'World')

分片不会有越界，因为当最后一个结束索引比实际大的时候，取最后一个索引：  

例如：  

	>>> a[:6]
	('Hello', 'World', 1, 3, 4)
	>>> a[1:6]
	('World', 1, 3, 4)
	>>> a[1:644]
	('World', 1, 3, 4)

#### 8.2.2.3 通过“拆包”访问元组

也可以叫做“解包”，就是将元组中的元素去除分别放进不同的变量中的过程。  

例如：  

	>>> a = ('Hello',"World",1,2,3)
	>>> a
	('Hello', 'World', 1, 2, 3)
	>>> str1,str2,n1,n2,n3 = a
	>>> str1
	'Hello'
	>>> str2
	'World'
	>>> n1
	1
	>>> n2
	2
	>>> n3
	3

还可以用另外一种方式赋值，\*代表将剩下的元组内容全部赋给该变量，该变量的类型是一个列表。  

例如：  

	>>> a = ('Hello',"World",1,2,3)
	>>> a
	>>> str1,str2,*n = a
	>>> n
	[1, 2, 3]
	>>> type(n)
	<class 'list'>

假如当对某个元素不关心时，可以用“\_”替代。  

例如：  

	>>> a = ('Hello',"World",1,2,3)
	>>> a
	('Hello', 'World', 1, 2, 3)
	>>> str1,str2,n1,n2,_ = a
	>>> str1
	'Hello'
	>>> str2
	'World'
	>>> n1
	1
	>>> n2
	2

	>>> a = ('Hello',"World",1,2,3)
	>>> a
	('Hello', 'World', 1, 2, 3)
	>>> str1,_,n1,_,n3 = a
	>>> str1
	'Hello'
	>>> n1
	1
	>>> n3
	3

### 8.2.3 遍历元组

遍历元组也完全适合于遍历所有的序列。  
因为一般都是使用for循环，因为for循环似乎天生就是为了遍历元素而存在的。  

普通的遍历：  

	>>> a = (21,3,24,5,4)
	>>> for item in a:
	        print(item)
	
	21
	3
	24
	5
	4

该循环不可通过索引来进行遍历。  

通过索引序号进行遍历如下：  

	>>> a = (21,3,24,5,4)
	>>> for idx,item in enumerate(a):
		print("{0} - {1}".format(idx,item))
	
		
	0 - 21
	1 - 3
	2 - 24
	3 - 5
	4 - 4
	>>>

前一列为索引序号，后一列为对应的所用序号的元组元素。

## 8.3 列表

列表（list）也是一种序列结构，与元组的区别是：  
1. 元组是不可以修改的，列表是可以修改的。  
2. 列表可以修改、追加、删除、替换和插入。

### 8.3.1 列表创建

创建列表也可以通过它的构造函数 'list([iterable])' ，或者用中括号“[]”将元素包裹，元素之间用逗号分隔。与元组的区别是元组将元素放在“（）”中。  

例如：  

	>>> [2,3,4,5,6]
	[2, 3, 4, 5, 6]

如果直接输入元素，则创建的是元组：  

	>>> 2,3,4,5,6
	(2, 3, 4, 5, 6)

创建空列表如下：  

	>>> []
	[]

如果列表只有一个元素，则元素后面不用加“，”号： 

	>>> [2]
	[2]
	>>> [2,]
	[2]

这个和元组是不一样的。   
通过列表的构造函数创建列表：

	>>> list((23,5,56,6))
	[23, 5, 56, 6]
	>>> list([23,5,56,6])
	[23, 5, 56, 6]

参数可以是列表，也可以是元组。  

列表的构造函数的参数也可以是字符串：  

	>>> list("Hello")
	['H', 'e', 'l', 'l', 'o']
	>>> list('Hello')
	['H', 'e', 'l', 'l', 'o']

当列表的构造函数是一个范围的时候，如下：  

	>>> list(range(10))
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

### 8.3.2 列表追加元素

列表的追加元素分两种情况：  

1：一种是单个元素  
append()方法是追加单个元素  
2：追加另外一个列表  
列表的追加过程就是在现有的列表末尾进行追加。  
“+”运算符或extend()方法追加另外一个列表  

例如：

	>>> stu_list = ['张三','李四','王五']
	>>> stu_list.append('董六')
	>>> stu_list
	['张三', '李四', '王五', '董六']
	
	>>> stu_list += ['刘备','关羽']
	>>> stu_list
	['张三', '李四', '王五', '董六', '刘备', '关羽']
	
	>>> stu_list.extend(['张飞','赵云'])
	>>> stu_list
	['张三', '李四', '王五', '董六', '刘备', '关羽', '张飞', '赵云']

### 8.3.3 列表插入元素

列表的插入元素指在列表元素中的某个位置插入其他元素。  
使用list.insert(i,x)这个方法，其中i是指列表元素的索引位置，x是指要插入的元素。  

例如：  

	>>> stu_list.insert(2,'君帅')
	>>> stu_list
	['张三', '李四', '君帅', '王五', '董六', '刘备', '关羽', '张飞', '赵云']
	可以使用负索引进行列表的插入：
	>>> stu_list.insert(-2,'君帅')
	>>> stu_list
	['张三', '李四', '君帅', '王五', '董六', '刘备', '关羽', '君帅', '张飞', '赵云']

### 8.3.4 列表替换元素

列表的元素替换就是根据列表的下标索引将元素替换就可以了。  

例如：  

	>>> stu_list
	['张三', '李四', '君帅', '王五', '董六', '刘备', '关羽', '君帅', '张飞', '赵云']
	>>> 
	>>> stu_list[0] = "1"
	>>> stu_list
	['1', '李四', '君帅', '王五', '董六', '刘备', '关羽', '君帅', '张飞', '赵云']

可以用不同类型的元素进行替换:  

	>>> stu_list
	['1', '李四', '君帅', '王五', '董六', '刘备', '关羽', '君帅', '张飞', '赵云']
	>>> stu_list[2] = 2
	>>> stu_list
	['1', '李四', 2, '王五', '董六', '刘备', '关羽', '君帅', '张飞', '赵云']

### 8.3.5 列表删除元素

列表删除元素可以使用两种方法：  

1：remove()  
在remove()方法中，只有一个参数，该参数要删除的列表中的元素，如果没有该参数的元素，则抛出异常。  

	>>> stu_list
	['1', '李四', 2, '王五', '董六', '刘备', '关羽', '君帅', '张飞', '赵云']
	>>> stu_list.remove('王五')
	>>> stu_list
	['1', '李四', 2, '董六', '刘备', '关羽', '君帅', '张飞', '赵云']
	>>> stu_list.remove(2)
	>>> stu_list
	['1', '李四', '董六', '刘备', '关羽', '君帅', '张飞', '赵云']

由于已经没有元素2了，再使用该方法删除的时候则抛出异常：  

	>>> stu_list
	['1', '李四', '董六', '刘备', '关羽', '君帅', '张飞', '赵云']
	>>> stu_list.remove(2)
	Traceback (most recent call last):
	  File "<pyshell#107>", line 1, in <module>
	    stu_list.remove(2)
	ValueError: list.remove(x): x not in list
	>>>

2：pop()  

该方法有两种情况，一种是带着参数i的，如pop(i)，另一种则是不带着参数的情况。其中参数i为列表中的索引值，而且该方法的返回值为已经删除的列表元素。不带参数的pop()方法返回的是列表中的最后一个元素。  

例如：

	>>> stu_list
	['1', '李四', '董六', '刘备', '关羽', '君帅', '张飞', '赵云']
	>>> stu_list.pop(0)
	'1'
	>>> stu_list
	['李四', '董六', '刘备', '关羽', '君帅', '张飞', '赵云'] 
	>>> stu_list.pop()
	'赵云'
	>>> stu_list
	['李四', '董六', '刘备', '关羽', '君帅', '张飞']
	>>>

### 8.3.6 列表中其他常用方法

reverse() —— 倒置列表：  

    >>> a = [0,1,2,3,4,5,6,7,8,9,10]
    >>> a.reverse()
	>>> a
	[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

copy() —— 复制列表

	>>> a = [0,1,2,3,4,5,6,7,8,9,10]
	>>> a
	[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
	>>> b = a.copy()
	>>> a
	[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
	>>> b
	[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
  
clear() —— 清除列表

	>>> a = [1,2,3,4,5,6,7,8,9,10]
	>>> a
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a.clear()
	>>> a
	[]

index(x[,i[,j]])  

返回查找x第一次出现的索引，i是开始查找索引，j是结束查找索引。

	>>> a = [1,2,3,4,5,6,7,8,9,10]
	>>> a
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	>>> a.index(4)
	3
	>>> a.index(4,2,5)
	3

count(x) —— 返回x出现的次数  

	>>> a = [1, 2, 3, 3, 5, 6, 3, 8, 9, 10]
	>>> a
	[1, 2, 3, 3, 5, 6, 3, 8, 9, 10]
	>>> a.count(3)
	3

### 8.3.7 列表推导式

在Python语言中有一种特殊的表达式叫推导式。这种推导式在列表中、集合中和字典中都有。  
就是输入一个列表结构，通过推导表达式会输出一个新的列表结构。  
如下：  

    n_list = [x ** 2 for x in range(10) if x % 2 == 0]  

    其中：  
    x ** 2        —— 输出表达式，对每个元素进行计算
    x             —— 元素变量
    rang(10)      —— 输入序列
    if x % 2 == 0 —— 条件语句，即过滤条件（可省略）

例如：  
计算1~10之间偶数的平方：  

	>>> n_list = []
	>>> for x in range(10):
		if x % 2 ==0:
		    n_list.append(x ** 2)
	
		    
	>>> n_list
	[0, 4, 16, 36, 64]
	
	>>> n_list = [x ** 2 for x in range(10) if x % 2 == 0]
	>>> n_list
	[0, 4, 16, 36, 64]

当没有条件的情况下下：  

	>>> n_list = [x ** 2 for x in range(10)]
	>>> n_list
	[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

当有多个条件的情况：  

	>>> n_list = [x ** 2 for x in range(100) if x % 2 == 0 if x > 10 if x<90]
	>>> n_list
	[144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744]
	
	>>> n_list = [x ** 2 for x in range(100) if x % 2 == 0 if x % 5 == 0]
	>>> n_list
	[0, 100, 400, 900, 1600, 2500, 3600, 4900, 6400, 8100]  

另外一种写法：  

	>>> n_list = [x ** 2 for x in range(100) if x % 2 == 0 and x % 5 == 0]
	>>> n_list
	[0, 100, 400, 900, 1600, 2500, 3600, 4900, 6400, 8100]

## 8.4 集合

集合的特点：  
集合中不能有重复的元素，而且集合中的元素是无序的。跟列表是完全不同的。  
由于集合是无序的，所以集合没有下标索引。  

集合分为两种情况：  
可变集合和不可变集合。

### 8.4.1 创建可变集合

可变集合在创建之后是可以修改的，主要是对集合进行元素的添加和删除等操作。  
set([iterable])函数，或者用大括号{}  

例如：

	>>> a = {"刘备","关羽","张飞"}
	>>> a
	{'关羽', '张飞', '刘备'}
	>>> type(a)
	<class 'set'>
	
	>>> a = {"刘备","关羽","张飞","张飞"}
	>>> a
	{'关羽', '张飞', '刘备'}
	
	>>> set((1,2,3,4,5,6,7))
	{1, 2, 3, 4, 5, 6, 7}
	>>> set([1,2,3,4,5,6,7])
	{1, 2, 3, 4, 5, 6, 7}
	>>> set([1,2,3,4,5,6,7,7])
	{1, 2, 3, 4, 5, 6, 7}

### 8.4.2 修改可变集合

add(elem)  

添加元素，如果元素已经存在，则不能添加，不会抛出错误。  

例如：  

	>>> a = {"刘备","关羽","张飞"}
	>>> a.add("赵云")
	>>> a
	{'关羽', '张飞', '刘备', '赵云'}
	>>> a.add("赵云")
	>>> a
	{'关羽', '张飞', '刘备', '赵云'}

remove(elem)  

删除元素，如果元素不存在，则抛出错误。  

例如：  

	>>> a = {"刘备","关羽","张飞"}
	>>> a.add("君帅")
	>>> a
	{'君帅', '关羽', '张飞', '刘备'}
	>>> a.remove("君帅")
	>>> a
	{'关羽', '张飞', '刘备'}
	>>> a.remove("君帅")
	Traceback (most recent call last):
	  File "<pyshell#218>", line 1, in <module>
	    a.remove("君帅")
	KeyError: '君帅'

discard(elem)

删除元素，如果元素不存在，不会抛出错误。  

例如：  

	>>> a = {"刘备","关羽","张飞"}
	>>> a.discard("君帅")
	>>> a
	{'关羽', '张飞', '刘备'}

pop()

删除返回集合中任意一个元素，返回值是删除的元素。  
由于集合并不像列表是没有索引的，所以在集合中不会有带索引参数的pop()方法。  

例如：  

	>>> a = {"刘备","关羽","张飞"}
	>>> a.add("赵云")
	>>> a.add("马超")
	>>> a.add("黄忠")
	>>> a.add("诸葛亮")
	>>> a
	{'诸葛亮', '黄忠', '张飞', '关羽', '马超', '刘备', '赵云'}
	>>> a.pop()
	'诸葛亮'
	>>> a.pop()
	'黄忠'
	>>> a.pop()
	'张飞'
	>>> a
	{'关羽', '马超', '刘备', '赵云'}

clear()  

清除集合。  

例如：  

	>>> a = {'诸葛亮', '黄忠', '张飞', '关羽', '马超', '刘备', '赵云'}
	>>> a
	{'诸葛亮', '黄忠', '张飞', '关羽', '马超', '刘备', '赵云'}
	>>> a.clear()
	>>> a
    set()

### 8.4.3 遍历集合

遍历集合与遍历列表是类似的，可以通过for循环来执行。  
但是需要注意由于集合是无序的，没有索引，所以不能通过下表访问来获得元素。  

例如：  

	>>> a = {'诸葛亮', '黄忠', '张飞', '关羽', '马超', '刘备', '赵云'}
	>>> for item in a:
		print(item)
	
	诸葛亮
	黄忠
	张飞
	关羽
	马超
	刘备
	赵云
	
	>>> a = {'诸葛亮', '黄忠', '张飞', '关羽', '马超', '刘备', '赵云'}
	>>> for idx,x in enumerate(a):
		print("{0}-{1}".format(idx,x))
	
		
	0-诸葛亮
	1-黄忠
	2-张飞
	3-关羽
	4-马超
	5-刘备
	6-赵云

注意左侧的idx是遍历集合的顺序而不是下标索引，因为集合中的元素没有顺序即不会有下标索引。

### 8.4.4 不可变集合

不可变集合的类型是frozenset。  
利用构造函数frozenset([iterable])来进行创建，不能使用大括号{}。  

例如：
	>>> a = frozenset({"刘备","关羽","张飞","赵云","马超","黄忠"})
	>>> a
	frozenset({'马超', '刘备', '张飞', '赵云', '关羽', '黄忠'})
	>>> type(a)
	<class 'frozenset'>
	>>> a.add("诸葛亮")
	Traceback (most recent call last):
	  File "<pyshell#6>", line 1, in <module>
	    a.add("诸葛亮")
	AttributeError: 'frozenset' object has no attribute 'add'

### 8.4.5 集合推导式

集合推导式和列表推导式非常类似，用法也非常类似，只是集合推导式输出的是一个集合。  

例如  

	>>> n_set = {x ** 2 for x in range(10) if x % 2 == 0}
	>>> n_set
	{0, 64, 4, 36, 16}

只是将列表的中括号“[]”换成了大括号“{}”。

	>>> input_list = [2,3,4,5,6,7,7,7,7]
	>>> input_set = {2,3,4,5,6,7,7,7,7}
	>>> 
	>>> n_list = [x ** 2 for x in input_list]
	>>> n_set = {x ** 2 for x in input_set}
	>>> 
	>>> n_list
	[4, 9, 16, 25, 36, 49, 49, 49, 49]
	>>> n_set
	{4, 36, 9, 16, 49, 25}  

集合的推导式会将重复的元素都剔除掉，然后进行运算。

## 8.5 字典

字典是可以迭代，可变的一类对象。  
由键值对所组成的，其中键是不可以重复的，键其实就是一个set集合。  
值是可重复的一类集合，但是值并不是列表，因为值之间是没有顺序的。

### 8.5.1 创建字典

创建字典使用dict()函数，或者用大括号{}将“键：值”对包裹，“键：值”对之间用逗号分隔。  

例如：  

	>>> dict1 = {102:"刘备",103:"关羽",104:"张飞"}
	>>> dict1
	{102: '刘备', 103: '关羽', 104: '张飞'}
	>>> type(dict1)
	<class 'dict'>

空字典的创建：  

	>>> dict2 = {}
	>>> dict2
	{}
	>>> type(dict2)
	<class 'dict'>

注意，空的大括号所创建的是一个字典类型而并不是一个集合类型。  
通过构造函数创建字典，参数为三个二元组：  

	>>> d1 = dict(((102,"刘备"),(103,"关羽"),(104,"张飞")))
	>>> d1
	{102: '刘备', 103: '关羽', 104: '张飞'}

通过构造函数创建字典，参数为三个元组列表：  

	>>> d1 = dict([(102,"刘备"),(103,"关羽"),(104,"张飞")])
	>>> d1
	{102: '刘备', 103: '关羽', 104: '张飞'}

用一个字典创建另外一个字典：  

	>>> d1 = dict({102: '刘备', 103: '关羽', 104: '张飞'})
	>>> d1
	{102: '刘备', 103: '关羽', 104: '张飞'}

特殊形式的创建dict(key1 = value1, key2 = value2, key3 = value3…)在这里key必须是字符串，而且字符串要省略单引号或者双引号，整数做键是不行的。  

例如：

	>>> d1 = dict(key1 = "刘备",key2 = "关羽",key3 = "张飞")
	>>> d1
	{'key1': '刘备', 'key2': '关羽', 'key3': '张飞'}
	>>> d1['key2']
	'关羽'

键值不能为整数：  

	>>> d1 = dict(102 = "刘备",103 = "关羽",104 = "张飞")
	SyntaxError: keyword can't be an expression
	
	>>> d1 = dict(aa = "刘备",bb = "关羽",cc = "张飞")
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞'}

键不能加单引号，否则会报异常： 

	>>> d1 = dict('102' = "刘备",'103' = "关羽",'104' = "张飞")
	SyntaxError: keyword can't be an expression

### 8.5.2 修改字典

字典的修改主要有三个方面：添加、替换、删除。  
其中删除中包括：del语句、pop(key[,default])方法和popitem()方法。  

例如：
添加操作：  

	>>> d1 = dict(aa = "刘备",bb = "关羽",cc = "张飞")
	>>> d1[101] = "刘备"
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}

修改操作：  

	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1['aa'] = "诸葛亮"
	>>> d1
	{'aa': '诸葛亮', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}

删除操作：  

	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> del d1['aa']
	>>> d1
	{'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	
	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1.pop('aa')
	'刘备'
	>>> d1
	{'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	
	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1.pop(101)
	'刘备'
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞'}
	>>> d1.pop(101)
	Traceback (most recent call last):
	  File "<pyshell#106>", line 1, in <module>
	    d1.pop(101)
	KeyError: 101

当指定默认值的时候就不会抛出异常错误：  

	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1.pop(101)
	'刘备'
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞'}
	>>> d1.pop(101)
	Traceback (most recent call last):
	  File "<pyshell#106>", line 1, in <module>
	    d1.pop(101)
	KeyError: 101
	>>> d1.pop(101,'刘备')
	'刘备'

返回删除键值对的二元组：  

	>>> d1.popitem()
	(101, '刘备')
	>>> d1.popitem()
	('cc', '张飞')

### 8.5.3 访问字典

get(key[,default])

通过键返回值，如果键不存在返回默认值。  

例如：  

	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1.get(101)
	'刘备'

items()  

返回字典的所有键值对  

	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1.items()
	dict_items([('aa', '刘备'), ('bb', '关羽'), ('cc', '张飞'), (101, '刘备')])

keys()  

返回字典键视图  

	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1.keys()
	dict_keys(['aa', 'bb', 'cc', 101])

values()  

返回字典值视图  

	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1.values()
	dict_values(['刘备', '关羽', '张飞', '刘备'])

### 8.5.4 遍历字典

字典的遍历同样是通过for循环进行遍历，但是字典是以键值对的形式存在的，则就会出现遍历键和遍历值的问题存在。  

例如：  

	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> for ky in d1.keys():
		print(ky)
	
	aa
	bb
	cc
	101
	
	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> for val in d1.values():
		print(val)
	
	刘备
	关羽
	张飞
	刘备
	    
	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> for id,name in d1.items():
		print(id,name)
	
		
	aa 刘备
	bb 关羽
	cc 张飞
	101 刘备

### 8.5.5 字典推导式

	>>> d1 = {'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> d1
	{'aa': '刘备', 'bb': '关羽', 'cc': '张飞', 101: '刘备'}
	>>> 
	>>> output_dict = {k:v for k,v in d1.items() if v != '刘备' }
	>>> output_dict
	{'bb': '关羽', 'cc': '张飞'}













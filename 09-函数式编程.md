
## 9.1 定义函数

1：Python官方提供的，称为内置函数（Built-in Functions，BIF）。  
2：函数的语法格式如下：  

    def 函数名（参数列表）：  
        函数体
        return 返回值

注意，在Python中，函数的参数列表是没有数据类型的，这个与其他语言不同。函数的参数列表之间用“，”分隔。  函数的返回值同样不需要数据类型。没有数据返回省略return语句或return None。

例如：

    >>> def rectangle_area(width, height):
	area = width * height
	return area

    >>> r_area = rectangle_area(320.0,480.0)
    >>> r_area
    153600.0

由于Python是解释性语言，从上到下进行解释执行，因此函数的调用语句应该编写在函数定义之下。

## 9.2 函数参数

### 9.2.1 使用关键字参数调用函数

所谓关键字参数就是在函数调用过程中给参数指定一个名字。  
在调用函数时，一旦其中一个参数采用了关键字参数形式传递，那么其后的所有参数都必须采用关键字参数形式传递。反之，如果采用关键字参数形式的参数之后没有采用关键字参数形式，则会发生编译错误。  

例如：  

	>>> def print_area(width,height):
		area = width * height
		print("{0} X {1} 长方形面积是： {2}".format(width,height,area))
	
	>>> print_area(16,25)
	16 X 25 长方形面积是： 400
	>>>
	>>> print_area(width = 16, height = 25)
	16 X 25 长方形面积是： 400
	>>> 
	>>> print_area(height = 25, width = 16)
	16 X 25 长方形面积是： 400
	>>> 
	>>> print_area(16, height = 25)
	16 X 25 长方形面积是： 400
	>>> 
	>>> print_area(width = 16, 5)
	SyntaxError: positional argument follows keyword argument

这种关键字函数参数的调用的好处在于函数调用过程中，函数的参数列表顺序是可以被打乱的。也可以第一个参数不使用关键字，但必须注意一旦有使用关键字的参数了，后面的参数也一定要使用关键字。

### 9.2.2 参数默认值

在其他语言中函数可以采用重载实现多个版本。  
但在Python语言中不支持函数重载，而是使用参数默认值的方式提供类似函数重载的功能。因为参数默认值只需要定义一个函数就可以了，而重载则需要定义多个函数，这会增加代码量。  

例如：
	>>> def make_coffee(name='卡布奇诺'):
		return "制作一杯{0}咖啡".format(name)
	
	>>> 
	>>> coffee1 = make_coffee("拿铁")
	>>> coffee2 = make_coffee()
	>>> 
	>>> print(coffee1)
	制作一杯拿铁咖啡
	>>> print(coffee2)
	制作一杯卡布奇诺咖啡

### 9.2.3 可变参数

在Python语言中可变参数有两种，在参数前加\*或\*\*形式，\*可变参数在函数中被组装成一个元组，\**可变参数在函数中被组装成一个字典。

第一种可变参数：  

\*可变参数不是最后一个参数时，后面的参数需要采用关键字参数形式传递。  

例如：

    >>> def sum(*numbers, multiple = 1):
		total = 0.0
		for number in numbers:
			total += number
		    return total * multiple
	
	>>> print(sum(1,2,3,4,5,6))
	21.0
	>>> print(sum(1,2,3))
	6.0
	>>> print(sum(1,2,3,4,5,6,multiple = 3))
	63.0  
	
通过参数列表可以看出，最后一个参数必须使用关键字进行传递，否则会和前面的参数混淆。  

当如果已经有了一个元组，需要将元组作为参数进行传递时如下所示：  

    >>> def sum(*numbers, multiple = 2):
	total = 0.0
	for number in numbers:
		total += number
		return total*multiple

这个时候在以元组为调用参数时，需要将元组参数名前加“\*”进行解包。

第二种可变参数  

\**可变参数必须在正规参数之后，否则会发生编译错误。  

例如：  

	>>> def show_info(sep=":",**info):
		print("---------------")
		for key, value in info.items():
			print("{0} {2} {1}".format(key, value, sep))
	
	>>> show_info("->",name = "Tony",age = 18,sex = True)
	---------------
	name -> Tony
	age -> 18
	sex -> True
	>>> show_info(name = "Tony",age = 18,sex = True)
	---------------
	name : Tony
	age : 18
	sex : True

假设本身就有一个字典对象，则需要双星号“\*\*”拆包字典对象。  

	>>> stu_dict = {"name":"Tony","age":18}
	>>> show_info("==",**stu_dict)
	---------------
	name == Tony
	age == 18
	>>> 
	>>> stu_dict = {"name":"Tony","age":18}
	>>> show_info(**stu_dict, sex = True, sep="|")
	---------------
	name | Tony
	age | 18
	sex | True

## 9.3 函数返回值

1：无返回值函数  

简单来说无返回值就是省略了“return”语句，或者“return None”。  

例如：

    >>> def show_info(sep=":",**info):
	        print("---------------")
	        for key, value in info.items():
		        print("{0} {2} {1}".format(key, value, sep))
	
	#return None
	#或return

2：多返回值函数  

将返回值放入元组、列表这列数据结构当中进行函数返回。  

推荐使用返回元组，因为元组是不可变的。在传递过程中不能被修改，比较安全。  

例如：  

    >>> def position(dt,speed):
	        posx = speed[0] * dt
	        posy = speed[1] * dt
	    #return(posx,posy)
	    return posx,posy

    >>> move = position(60.0, (10,20))
    >>> print(move)
    (600.0, 1200.0)

## 9.4 函数变量作用域

变量可以在模块中创建，作用域是整个模块，称为全局变量。  
变量也可以在函数中创建，默认情况下作用域是整个函数，称为局部变量。  
变量还可以在类中创建，这样的变量被称为类的成员变量。  

例如：

    >>> #全局变量x
    >>> x = 20
    >>> 
    >>> def print_value():
	        x = 10
	        print("函数中x = {0}".format(x))

    >>> print_value()
        函数中x = 10
    >>> print("全局变量 x = {0}".format(x))
        全局变量 x = 20

当将函数中的局部变量注销掉，函数中可以访问全局变量：  

    >>> #全局变量x
    >>> x = 20
    >>> 
    >>> def print_value():
	        # x = 10
	        print("函数中x = {0}".format(x))
    >>> print_value()
        函数中x = 20
    >>> print("全局变量 x = {0}".format(x))
        全局变量 x = 20

当在函数中使用global，可以在函数中改变全局变量的值：  

    >>> # 全局变量x 
    >>> x = 20
    >>> 
    >>> def print_value():
	        global x
	        x = 10
	        print('函数中 x = {0}'.format(x))

    >>> print_value()
        函数中 x = 10
    >>> print('全局变量 x = {0}'.format(x))
        全局变量 x = 10  
        
这样做的弊端在于，某个函数方法将全局变量改变了，从而导致其他函数在使用该变量时发生错误。

## 9.5 生成器

在一个函数中使用return关键字返回数据，但是有时候会使用yield关键字返回数据。  
Yield关键字的函数返回的是一个生成器（generator）对象，生成器对象是一种可迭代对象。  
通过__next__()方法，获得元素。  

例如：  

    def square(num):
        n_list = []
        for i in range(1, num + 1):
            n_list.append(i * i)

        return n_list

    for i in square(5):
        print(i,end= ' ')

结果：  

    1 4 9 16 25

一般对于一个很大的数列的话，这样的程序代码会非常占用内存。  

    def square(num):
        for i in range(1, num + 1):
            yield i * i

    for i in square(5):
        print(i,end= ' ')

yield语句可以返回一个元素，此时函数返回的生成器对象，生成器对象是一种特殊的迭代器对象。  

    >>> def square(num):
            for i in range(1, num + 1):
            yield i * i

    >>> n_seq = square(5)
    >>> n_seq.__next__()
    1  
    >>> n_seq.__next__()
    4
    >>> n_seq.__next__()
    9
    >>> n_seq.__next__()
    16
    >>> n_seq.__next__()
    25
    >>> n_seq.__next__()
    Traceback (most recent call last):
    File "<pyshell#24>", line 1, in <module>
    n_seq.__next__()
    StopIteration

从以上程序可以看出，调用一次返回一个函数。  
多有的迭代器都可以调用“\_\_next\_\_()”函数方法。  
  
生成器特别适用于遍历一些大序列对象，它无须将对象的所有元素都载存入内存后才开始进行操作。而是仅在迭代至某个元素时才会将该元素载放入内存。

## 9.6 嵌套函数

在一个函数体内定义另外一个函数，称作“嵌套函数”。  

1：嵌套函数可以访问所在外部函数中的变量，但外部函数不能访问嵌套函数局部变量。  

2：不能在外部函数体之外直接访问嵌套函数。  

例如：  

    def calculate(n1, n2, opr):
    multiple = 2

    # 定义相加函数
    def add(a, b):
        return (a + b) * multiple

    # 定义相减函数
    def sub(a, b):
        return (a - b) * multiple

    if opr == '+':
        return add(n1, n2)
    else:
        return  sub(n1,n2)

    print(calculate(10, 5, '+'))
    print(calculate(10, 5, '-'))

    30    
    10

## 9.7 函数式编程基础

函数式编程（functional programming）与面向对象编程一样都一种编程范式，函数式编程，也称为面向函数的编程。  

函数式编程并不能处理所有问题，函数式编程重点处理的是一些计算，处理数据。  

技术基础：函数类型、Lambda表达式、匿名函数和高阶函数。

### 9.7.1 函数类型

所有函数都有函数类型，函数类型其实也是一种数据类型。函数类型实例与普通类型实例所使用的场景时一样的：  

* 可以赋值给一个变量；  
* 可以作为一个函数的参数使用；
* 可以作为一个函数的返回值使用。
  
例如：  

    def calculate_fun(opr):
    multiple = 2

    # 定义相加函数
    def add(a, b):
        return (a + b) * multiple

    # 定义相减函数
    def sub(a, b):
        return (a - b) * multiple

    if opr == '+':
        return add
    else:
        return  sub

    f1 = calculate_fun('+')
    f2 = calculate_fun('-')

    print(f1(10, 5))
    print(f2(10, 5))
    
    30
    10

### 9.7.2 Lambda表达式

Lambda表达式本质上是一种匿名函数，匿名函数也是函数，有函数类型，也可以创建函数对象。  

定义Lambda表达式语法如下：  

    lambda参数列表：Lambda体

注意，Lambda体部分不能是一个代码块，不能包含多条语句，只有一条语句，语句会计算一个结果返回给Lambda表达式，但是与函数不同的是不需要使用return语句返回。与其他语言中的Lambda表达式相比，Python中提供Lambda表达式只能处理一些简单的计算。  

例如：  

    def calculate_fun(opr):

    if opr == '+':
        return lambda a, b: (a + b)
    else:
        return lambda a, b: (a - b)

    f1 = calculate_fun('+')
    f2 = calculate_fun('-')

    print(f1(10, 5))
    print(f2(10, 5))

    15
    5

### 9.7.3 三大基础函数

函数式编程主要是对数据进行处理：过滤、映射和聚合。  

Python提供了三个基础的函数：filter()、map()和reduce()。

1：filter()
过滤操作使用filter()函数，它可以对可迭代对象元素进行过滤，filter()函数语法如下：  

    filter(function, iterable)

function函数返回布尔值，在function函数中编写过滤条件，如果为True的元素被保留，如果为False的元素被过滤掉。filter函数返回的一个列表。  

例如：  

    users = ['Tony', 'Tom', 'Ben', 'Alex']
    users_filter = filter(lambda u: u.startswith('T'), users)
    print(list(users_filter))

    ['Tony', 'Tom']

    number_list = range(1, 11)
    number_filter = filter(lambda it: it % 2 == 0,number_list)
    print(list(number_filter))

    [2, 4, 6, 8, 10]

2：map()  

映射操作使用map()函数，它可以对可迭代对象的元素进行变换，map()函数语法如下：    
    map(function, iterable)  

例如：  

    users = ['Tony', 'Tom', 'Ben', 'Alex']
    users_map = map(lambda u:u.lower(), users)
    print(list(users_map))
    
    ['tony', 'tom', 'ben', 'alex']

    users_map = map(lambda u: u.lower(), filter(lambda u: u.startswith('T'), users))
    print(list(users_map))

    ['tony', 'tom']

    number_list = range(1, 11)

    number_filter = filter(lambda it: it % 2 == 0,number_list)
    number_map = map(lambda it: it ** 2, number_filter)
    print(list(number_map))

    [4, 16, 36, 64, 100]

3：reduce()  

聚合操作中最基础的是归纳函数reduce()，reduce()函数会将多个数据按照指定的算法积累叠加（也有可能乘或除）起来，最后输出一个数据。  

reduce()函数语法如下：  

    reduce(function, iterable[,initializer])

例如：   

    a = (1, 2, 3, 4)
    a_reduce = reduce(lambda acc, i: acc + i, a)
    print(a_reduce)

    10

其中，acc这个参数是上一次经过处理以后的值，即两个参数累加后的值，在下一次计算时该acc值再次参与计算。

    a = (1, 2, 3, 4)
    a_reduce = reduce(lambda acc, i: acc + i, a, 2)
    print(a_reduce)

    12

设置初始值为2，最后的结果为累加后的12。当没有设置初始值的时候，初始值默认为0。





